C51 COMPILER V9.56.0.0   ____________________                                              05/25/2017 17:22:24 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE ____________________
OBJECT MODULE PLACED IN 徐德宝毕业设计源程序.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE 徐德宝毕业设计源程序.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(
                    -2)

line level    source

   1          #include<reg52.h>
   2          #include <intrins.h>
   3          #define uchar unsigned char
   4          #define uint unsigned int
   5          #define PCF8591_ADDR  0x90    //PCF8591地址
   6          uchar code table[]="   2000-00-00 "; // 1602初始数据
   7          uchar code table1[]=" 00:00:00";
   8          uchar num,AD_Value,count,count1,shi,fen,miao,s1num,ri,yue,nian;
   9          sbit dula = P2^6;
  10          sbit wela = P2^7;
  11          sbit SDA = P2^0;  // I2C数据线
  12          sbit SCL = P2^1;  // I2C时钟线
  13          sbit E181 = P2^2;// 测距传感器1(是否有人)（蓝）
  14          sbit E182 = P2^4;// 测距传感器2(是否过近)（红）
  15          sbit kaiguan = P2^5; // 模式切换开关
  16          sbit lcden = P3^4;// 使能端位定义
  17          sbit lcdrs = P3^5;// 命令/数据选择端位定义
  18          sbit lcdwr = P3^6;// 读/写选择端位定义
  19          sbit fm = P2^3;  // 蜂鸣器
  20          /*要用3个独立按键s1，s2，s3来调整数字"秒、分、时、日、月、年，s1按键作为跳到要调整的位上，
  21            s2按键作为数据的递增，s3按键作为数据的递减"*/
  22          sbit s1 = P3^0;
  23          sbit s2 = P3^1;
  24          sbit s3 = P3^2;
  25          
  26          void delay(uint z) // zms延时函数
  27          {
  28   1        uint x,y;
  29   1        for(x=z;x>0;x--)
  30   1          for(y=114;y>0;y--);
  31   1      }
  32          
  33          /*5us延时*/
  34          void delay_5us()  
  35          {
  36   1        _nop_();
  37   1      }
  38          
  39          void write_com(uchar com) // 写命令子函数（结合写操作时序图）
  40          {
  41   1        lcdrs = 0;// 命令/数据选择端(置0选择写“命令”)
  42   1        P0 = com; // 送数据
  43   1        delay(5); // 延时                      
  44   1        lcden = 1;// 使能端给高脉冲
  45   1        delay(5); // 延时                     
  46   1        lcden = 0;// 使能端给低脉冲 
  47   1      }
  48          
  49          void write_data(uchar date)// 写数据子函数（结合写操作时序图）
  50          {
  51   1        lcdrs = 1; // 命令/数据选择端(置1选择写“数据”)
  52   1        P0 = date;
  53   1        delay(5);                        
  54   1        lcden = 1;
C51 COMPILER V9.56.0.0   ____________________                                              05/25/2017 17:22:24 PAGE 2   

  55   1        delay(5);                       
  56   1        lcden = 0;  
  57   1      }
  58          
  59          void init()
  60          {
  61   1        wela = 1; // 位锁存端（以使数码管保持不亮）
  62   1        P0 = 0xff;
  63   1        wela = 0;
  64   1        dula = 1; // 段锁存端（以使数码管保持不亮）
  65   1        P0 = 0x00;
  66   1        dula = 0; 
  67   1        lcden = 0;// 使能端初始化
  68   1        lcdwr = 0;// 读/写选择端初始化（置0，选择写数据）
  69   1        write_com(0x38);//  设置16*2显示，5*7点阵，8位数据接口
  70   1        write_com(0x0c);// 开显示，关光标
  71   1        write_com(0x06);// 光标加1，且不移动
  72   1        write_com(0x80);// 设置数据地址（第一个字）
  73   1        for(num = 0;num < 14;num++)               
  74   1        {
  75   2          write_data(table[num]);
  76   2          delay(10); // 每隔约10ms显示一个字符         
  77   2        }
  78   1        write_com(0x80+0x43);//0x80表示从第一行第一个字开始显示,再加0x43从第二行第4个字开始显示
  79   1        for(num = 0;num < 9;num++)
  80   1        {
  81   2          write_data(table1[num]);
  82   2          delay(10); // 每隔约10ms显示一个字符        
  83   2        }
  84   1        TMOD = 0x11;// 定时器0-工作方式1，定时器1-工作方式1
  85   1        TH0 = (65536-50000)/256;
  86   1        TL0 = (65536-50000)%256;
  87   1        ET0 = 1;  
  88   1        TR0 = 1;
  89   1        TH1 = (65536-50000)/256;
  90   1        TL1 = (65536-50000)%256;
  91   1        ET1 = 1;
  92   1        TR1 = 0;  // 初始时，先关闭定时器1
  93   1        EA = 1; 
  94   1      } 
  95          
  96          void shifenmiao(uchar add,uchar date)/*这个子函数用于刷新时、分、秒变化后数值，
  97           列如00:00:00,在秒每次加1之后，都要送入新的数值给”所对应地址上的“秒“，并且秒是两位数据，
  98           所以要将这两位数据分离开来分别送到对应的位置，而且送的数据应该是这个数据对应的16进制编码，
  99           0所对应的十六进制编码为0x30（根据字符手册），故对于某一数值x，它对应的16进制编码应该是0x30+x*/
 100          {
 101   1        uchar shi,ge;
 102   1        shi = date/10;
 103   1        ge = date%10;
 104   1        write_com(0x80+0x40+add);//确定出所要送的时(分或秒)的数据的地址（以便下面送入数据）
 105   1        write_data(0x30+shi); //将时(分或秒)的数据的十位送到上面行中的地址
 106   1        write_data(0x30+ge);  //将时(分或秒)的数据的个位送到上面行中的地址
 107   1      }
 108          
 109          void riyuenian(uchar add1,uchar date1)/*这个子函数用于刷新日、月、年变化后数值，具体过程同时、分、秒*/
 110          {
 111   1        uchar shi1,ge1;
 112   1        shi1 = date1/10;
 113   1        ge1 = date1%10;
 114   1        write_com(0x80+add1);//确定出所要送的日(月或年)的数据的地址（以便下面送入数据）
 115   1        write_data(0x30+shi1); //将日(月或年)的数据的十位送到上面一行中的地址
 116   1        write_data(0x30+ge1);  //将日(月或年)的数据的个位送到上面的地址
C51 COMPILER V9.56.0.0   ____________________                                              05/25/2017 17:22:24 PAGE 3   

 117   1      }
 118          
 119          void keyscan()
 120          {
 121   1        if(s1==0)// 如果第一个键按下  
 122   1        {
 123   2          delay(5);//消抖
 124   2          if(s1==0) // 如果第一个键确实按下
 125   2          { 
 126   3            s1num++;// s1num记录闪烁的顺序
 127   3            while(!s1);// 第一个键的松手检测
 128   3            if(s1num==1) // 如果光标在”秒“上闪烁
 129   3            {
 130   4              TR0=0;// 闪烁时关闭定时器
 131   4              write_com(0x80+0x40+11);// 确定"秒"的地址
 132   4              write_com(0x0f);//开显示，开光标闪烁，等待修改
 133   4            }
 134   3           }
 135   2          if(s1num==2)// 如果光标在”分“上闪烁
 136   2          {
 137   3            write_com(0x80+0x40+8);// 确定"分"的地址
 138   3          }
 139   2          if(s1num==3) // 如果光标在”时“上闪烁
 140   2          {
 141   3            write_com(0x80+0x40+5);// 确定"时"的地址
 142   3          }
 143   2          if(s1num==4) // 如果光标在”日“上闪烁
 144   2          {
 145   3            write_com(0x80+12);// 确定"日"的地址
 146   3          }
 147   2          if(s1num==5) // 如果光标在”月“上闪烁
 148   2          {
 149   3            write_com(0x80+9);// 确定"月"的地址
 150   3          }
 151   2          if(s1num==6) // 如果光标在”年“上闪烁
 152   2          {
 153   3            write_com(0x80+6);// 确定"年"的地址
 154   3          }
 155   2          if(s1num==7) // 停止闪烁
 156   2          {
 157   3            s1num=0;
 158   3            write_com(0x0c);//开显示，关光标闪烁
 159   3            TR0=1;// 开定时器，继续计时
 160   3          }     
 161   2        }
 162   1        if(s1num!=0)// 在第一个键按下之后如果再有键按下（即光标在闪烁）
 163   1        {
 164   2          if(s2==0) // 按下第二个键
 165   2          {
 166   3            delay(5);//消抖
 167   3            if(s2==0) // 确实按下第二个键
 168   3            {
 169   4              while(!s2);// 第二个键的松手检测
 170   4              if(s1num==1)//如果光标在”秒“上闪烁,那么本层if循环对”秒“的数据进行修改
 171   4              {
 172   5                miao++;
 173   5                if(miao==60)// 秒的增加到达60，则要清零
 174   5                  miao=0;
 175   5                shifenmiao(10,miao);//发送数据  
 176   5                write_com(0x80+0x40+11);// 确定修改数据的地址   
 177   5              }
 178   4              if(s1num==2)//如果光标在”分“上闪烁,那么本层if循环对”分“的数据进行修改
C51 COMPILER V9.56.0.0   ____________________                                              05/25/2017 17:22:24 PAGE 4   

 179   4              {
 180   5                fen++;
 181   5                if(fen==60)// 同上
 182   5                  fen=0;
 183   5                shifenmiao(7,fen);// 同上
 184   5                write_com(0x80+0x40+8); // 同上   
 185   5              }
 186   4              if(s1num==3)//如果光标在”时“上闪烁,那么本层if循环对”时“的数据进行修改
 187   4              {
 188   5                shi++;
 189   5                if(shi==24)// 同上
 190   5                  shi=0;
 191   5                shifenmiao(4,shi);// 同上
 192   5                write_com(0x80+0x40+5);// 同上  
 193   5              }
 194   4              if(s1num==4)//如果光标在”日“上闪烁,那么本层if循环对”日“的数据进行修改
 195   4              {
 196   5                ri++;
 197   5                if(ri==31)// 同上
 198   5                  ri=1;
 199   5                riyuenian(11,ri);
 200   5                write_com(0x80+12);//同上 
 201   5              }
 202   4              if(s1num==5)//如果光标在”月“上闪烁,那么本层if循环对”月“的数据进行修改
 203   4              {
 204   5                yue++;
 205   5                if(yue == 13)
 206   5                  yue = 1;
 207   5                riyuenian(8,yue);
 208   5                write_com(0x80+9);//同上  
 209   5              }
 210   4              if(s1num==6)//如果光标在”年“上闪烁,那么本层if循环对”年“的数据进行修改
 211   4              {
 212   5                nian++;
 213   5                if(nian == 100)
 214   5                  nian = 0;
 215   5                riyuenian(5,nian);
 216   5                write_com(0x80+6);//同上  
 217   5              }
 218   4            }
 219   3          }
 220   2          if(s3==0)// 如果按下第三个键
 221   2            {
 222   3            delay(5);//消抖
 223   3            if(s3==0)
 224   3            {
 225   4              while(!s3);// 第三个键的松手检测
 226   4              if(s1num==1)//如果光标在”秒“上闪烁,那么本层if循环对”秒“的数据进行修改
 227   4              {
 228   5                miao--;
 229   5                if(miao==-1)// 如果秒为负数，则退回59
 230   5                  miao=59;
 231   5                shifenmiao(10,miao);
 232   5                write_com(0x80+0x40+11);  
 233   5              }
 234   4              if(s1num==2)//如果光标在”分“上闪烁,那么本层if循环对”分“的数据进行修改
 235   4              {
 236   5                fen--;
 237   5                if(fen==-1)  //同上
 238   5                  fen=59; 
 239   5                shifenmiao(7,fen);//同上
 240   5                write_com(0x80+0x40+8);//同上 
C51 COMPILER V9.56.0.0   ____________________                                              05/25/2017 17:22:24 PAGE 5   

 241   5              }
 242   4              if(s1num==3)//如果光标在”时“上闪烁,那么本层if循环对”时“的数据进行修改
 243   4              {
 244   5                shi--; //同上
 245   5                if(shi==-1) //同上
 246   5                  shi=23;
 247   5                shifenmiao(4,shi);
 248   5                write_com(0x80+0x40+5); //同上  
 249   5              }
 250   4                if(s1num==4)//如果光标在”日“上闪烁,那么本层if循环对”日“的数据进行修改
 251   4              {
 252   5                ri--; //同上
 253   5                if(ri==-1)  //同上
 254   5                  ri=30;
 255   5                riyuenian(11,ri);
 256   5                write_com(0x80+12); //同上  
 257   5              }
 258   4              if(s1num==5)//如果光标在”月“上闪烁,那么本层if循环对”月“的数据进行修改
 259   4              {
 260   5                yue--;
 261   5                if(yue == -1)
 262   5                  yue = 12;
 263   5                riyuenian(8,yue);
 264   5                write_com(0x80+9);//同上  
 265   5              }
 266   4              if(s1num==6)//如果光标在”年“上闪烁,那么本层if循环对”年“的数据进行修改
 267   4              {
 268   5                nian--;
 269   5                if(nian == -1)
 270   5                  nian = 99;
 271   5                riyuenian(5,nian);
 272   5                write_com(0x80+6);//同上  
 273   5              }
 274   4            }
 275   3            } 
 276   2        }   
 277   1      }
 278          
 279          /*I2C初始化*/
 280          void I2C_init() 
 281          {
 282   1        SDA = 1;
 283   1        _nop_(); // 短暂延时（约1ms），从而使总线稳定 ，以下_nop_()的作用与此相同
 284   1        SCL = 1;
 285   1        _nop_();
 286   1      }
 287          
 288          /*I2C起始信号*/
 289          void I2C_Start()  
 290          {
 291   1        SCL = 1;
 292   1        _nop_();
 293   1        SDA = 1;
 294   1        delay_5us();
 295   1        SDA = 0;
 296   1        delay_5us();
 297   1      }
 298          
 299          /*I2C终止信号*/
 300          void I2C_Stop()
 301          {
 302   1        SDA = 0;
C51 COMPILER V9.56.0.0   ____________________                                              05/25/2017 17:22:24 PAGE 6   

 303   1        _nop_();
 304   1        SCL = 1;
 305   1        delay_5us();
 306   1        SDA = 1;
 307   1        delay_5us();
 308   1      }
 309          
 310          /*主机向从机发送应答（由从机检测）*/
 311          void Master_ACK(bit i)    
 312          {
 313   1        SCL = 0; // 拉低时钟总线允许SDA数据总线上的数据变化
 314   1        _nop_(); // 让总线稳定
 315   1        if (i)   //如果i = 1 那么拉低数据总线 表示主机应答
 316   1        {
 317   2          SDA = 0;     //表示主机应答
 318   2        }
 319   1        else   
 320   1        {
 321   2          SDA = 1;  //表示主机非应答
 322   2        }
 323   1        _nop_();//让总线稳定
 324   1        SCL = 1;//拉高时钟总线 让从机从SDA线上读走 主机的应答信号
 325   1        delay_5us();
 326   1        SCL = 0;//拉低时钟总线， 占用总线继续通信
 327   1        _nop_();
 328   1        SDA = 1;//释放SDA数据总线。
 329   1        _nop_();
 330   1      }
 331          
 332          /*从机向主机发送应答（由主机检测）*/
 333          bit Test_ACK()
 334          {
 335   1        SCL = 1; // 时钟线为高时，可读取应答信号
 336   1        delay_5us();
 337   1        if (SDA)   // 如果从机没有应答
 338   1        {
 339   2          SCL = 0;// 因为从机没有应答，故主机要发停止信号，所以先将SCL拉低以允许数据变化
 340   2          _nop_();
 341   2          I2C_Stop(); // 主机发停止信号，结束本次通信
 342   2          return(0);  // 返回一个“0”,表示从机非应答
 343   2        }
 344   1        else  // 从机应答
 345   1        {
 346   2          SCL = 0;  // SCL依然要拉低，这是为主机向从机发数据做准备
 347   2          _nop_();
 348   2          return(1); // 返回一个“0”,表示从机应答
 349   2        }
 350   1      }
 351          
 352          /*I2C发送一个字节*/
 353          void I2C_send_byte(uchar byte)
 354          {
 355   1        uchar i;
 356   1        for(i = 0 ; i < 8 ; i++)
 357   1        {
 358   2          SCL = 0;  // 允许数据变化
 359   2          _nop_();
 360   2          if (byte & 0x80) // 如果为真，表明byte最高位为1，那么将这个“1”发送给SDA，然后发出去
 361   2          {       
 362   3            SDA = 1;  
 363   3            _nop_();           
 364   3          }       
C51 COMPILER V9.56.0.0   ____________________                                              05/25/2017 17:22:24 PAGE 7   

 365   2          else   // 如果为假，表明byte最高位为0，那么将这个“0”发送给SDA，然后发出去
 366   2          {
 367   3            SDA = 0;
 368   3            _nop_();
 369   3          }
 370   2          SCL = 1;  // 将SCL拉高，读取SDA总线数据
 371   2          _nop_();
 372   2          byte <<= 1; //byte左移1位，为下次数据发送做准备 
 373   2        }
 374   1        SCL = 0;
 375   1        _nop_();
 376   1        SDA = 1;
 377   1        _nop_();
 378   1      }
 379           
 380          /*I2C 读一个字节*/
 381          uchar I2C_read_byte()
 382          {
 383   1        uchar dat,i; // 读取到的数据存入dat
 384   1        SCL = 0;
 385   1        _nop_();
 386   1        SDA = 1;  // 释放总线
 387   1        _nop_();
 388   1        for(i = 0 ; i < 8 ; i++)
 389   1        {
 390   2          SCL = 1; // SCL为高，准备读取数据
 391   2          _nop_();
 392   2          if (SDA) // 如果读到一个“1”         
 393   2          {
 394   3             dat |= 0x01; // 将读到的“1”存入dat的最低位
 395   3          }
 396   2          else  // 如果读到一个“0”
 397   2          {
 398   3            dat &=  0xfe; // 将读到的“0”存入dat的最低位
 399   3          }
 400   2          _nop_();
 401   2          SCL = 0 ;
 402   2          _nop_();
 403   2          if(i < 7) /*因为一共要读取8次，每次都存放在最低位，故每次存放之后都要左移一位，为下次读取做准备，
 404   2                   【注意】：读取8次，只要左移7次，因为最后一次正好存放在最低位,不需要再移位*/
 405   2          {
 406   3            dat = dat << 1; 
 407   3          }
 408   2        }
 409   1        return(dat);//将读取到的一个字节返回给dat
 410   1      }
 411          
 412          /*I2C接收（读取）数据的过程*/
 413          /*读AD数据*/
 414          bit ADC_Read(uchar CON) // 本函数同AT24C02芯片接收数据时的receive函数作用相同，都是将数据存入芯片
 415          {
 416   1        I2C_Start();
 417   1        I2C_send_byte(PCF8591_ADDR+0); // PCF8591地址 0x90
 418   1        if (!Test_ACK())
 419   1        {
 420   2          return(0);
 421   2        }
 422   1        I2C_send_byte(CON);   //写入PCF8591控制字 
 423   1        Master_ACK(0);
 424   1        I2C_Start();
 425   1        I2C_send_byte(PCF8591_ADDR+1);
 426   1        if (!Test_ACK())
C51 COMPILER V9.56.0.0   ____________________                                              05/25/2017 17:22:24 PAGE 8   

 427   1        {
 428   2          return(0);
 429   2        }
 430   1        AD_Value = I2C_read_byte();
 431   1        Master_ACK(0);
 432   1        I2C_Stop();
 433   1        return(1);  
 434   1      }
 435          
 436          void test_time() // 测试入座时间
 437          {       
 438   1        if(E181 == 0)
 439   1        {
 440   2          TR1 = 1;
 441   2          if(count1 == 100) // 计时5秒到，亮警示灯   
 442   2          {
 443   3            count1 = 0;
 444   3            fm = 0;
 445   3            delay(1000);// 警示灯延时
 446   3            fm = 1;
 447   3            delay(1000);// 警示灯延时 
 448   3          }
 449   2        }
 450   1        else
 451   1        TR1 = 0;    
 452   1      } 
 453          
 454          void test_distance() // 测试距离
 455          {
 456   1        if(E182 == 0)
 457   1        {
 458   2          fm = 0;
 459   2          delay(500);// 警示灯延时
 460   2          fm = 1;
 461   2            delay(500);// 警示灯延时
 462   2        } 
 463   1      }
 464          
 465          void test_light() // 光控亮灯
 466          {
 467   1        ADC_Read(0x02); // 将返回值date发送给num   【注】：0x02为PCF8591的控制字   
 468   1        if((AD_Value > 150)&&(E181 == 0))       // 光照强度值num大于180时，灯自动点亮
 469   1        P1 = 0;
 470   1        else 
 471   1        P1 = 0xff;  
 472   1      }
 473          
 474          void main()
 475          {
 476   1        init();
 477   1        I2C_init();
 478   1        while(1)
 479   1        { 
 480   2          keyscan();
 481   2            if(kaiguan == 0) // 智能模式（1602显示+光控亮灯+定时提醒+测距）
 482   2          {   
 483   3            test_light();
 484   3            test_distance();
 485   3            test_time();
 486   3          }
 487   2          else // 普通模式 （1602显示+常亮灯）
 488   2          {
C51 COMPILER V9.56.0.0   ____________________                                              05/25/2017 17:22:24 PAGE 9   

 489   3            P1 = 0x00;
 490   3          }       
 491   2        }   
 492   1      }
 493              
 494          void timer0() interrupt 1//定时器0，工作方式1
 495          {
 496   1        TH0 = (65536-50000)/256;
 497   1        TL0 = (65536-50000)%256;
 498   1        count++;
 499   1        if(count == 18)//计时1秒到
 500   1          {
 501   2            count = 0;
 502   2            miao++;
 503   2            if(miao == 60)//计时1分钟到
 504   2            {
 505   3              miao = 0;
 506   3              fen++;
 507   3              if(fen == 60)//计时1小时到
 508   3              {
 509   4                fen = 0;
 510   4                shi++;
 511   4                if(shi == 24)//计时1日到
 512   4                {
 513   5                  shi = 0;
 514   5                  ri++;
 515   5                  if(ri == 31) //计时1个月到
 516   5                  {
 517   6                    ri = 1;
 518   6                    yue++;
 519   6                    if(yue == 13)//计时1年到
 520   6                    {
 521   7                      yue = 1;
 522   7                      nian++;
 523   7                      if(nian == 100)//计时99年到
 524   7                      {
 525   8                        nian = 0;
 526   8                      }
 527   7                      riyuenian(5,nian);//调用子函数用于刷新“年”的数据，并且显示在其指定的地址：0x80+5
 528   7                    }
 529   6                    riyuenian(8,yue);//刷新”月“，显示在：0x80+8
 530   6                  }
 531   5                  riyuenian(11,ri);//刷新”日“，显示在：0x80+11
 532   5                }
 533   4                shifenmiao(4,shi);//刷新“时”，显示在：0x80+0x40+4
 534   4              }
 535   3              shifenmiao(7,fen);//刷新”分“，显示在：0x80+0x40+7
 536   3            }
 537   2            shifenmiao(10,miao);//刷新”秒“，显示在：0x80+0x40+10
 538   2          }   
 539   1      }
 540          
 541          void timer1() interrupt 3//定时器1，工作方式1
 542          {
 543   1        TH1 = (65536-50000)/256;
 544   1        TL1 = (65536-50000)%256;
 545   1        count1++;     
 546   1      }
 547          
 548          
 549          
 550          
C51 COMPILER V9.56.0.0   ____________________                                              05/25/2017 17:22:24 PAGE 10  

 551          
 552          
 553          
 554          
 555          
 556          
 557          
 558          
 559          
 560          
 561          
 562          
 563          
 564          
 565          
 566          
 567          
 568          
 569          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1174    ----
   CONSTANT SIZE    =     25    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
